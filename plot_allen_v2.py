"""
plot_allen_v2.py

Interactive 3-slice viewer for summary outputs generated by simulate_allen_v3_mp.py.

- Input: output/allpoints_cell*_outsideOnly_integrated_mp_summary_fast_*.npy
  (or the latest matching summary file)
- Viewer: XY / YZ / ZX slices with x/y/z sliders
- Metric selection: RadioButtons for vm0_mV, vm_max_mV, vm_min_mV, spike_count
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Dict, Tuple

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, RadioButtons


def _find_default_input(script_dir: Path) -> Path | None:
    """Pick the most recently modified summary file in ./output."""
    outdir = script_dir / "output"
    if not outdir.is_dir():
        return None

    patterns = [
        "allpoints_cell*_outsideOnly_integrated_mp_summary_fast_*.npy",
        "allpoints_cell*_outsideOnly_integrated_mp_summary_*.npy",
    ]
    candidates = []
    for pat in patterns:
        candidates.extend(outdir.glob(pat))

    if not candidates:
        return None

    candidates.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return candidates[0]


def _load_payload(path: Path) -> dict:
    data = np.load(str(path), allow_pickle=True)
    if isinstance(data, np.ndarray) and data.ndim == 0:
        data = data.item()
    if not isinstance(data, dict):
        raise TypeError(f"Unexpected root type in npy: {type(data)}")

    required = [
        "positions_um",
        "positions_outside_indices",
        "vm0_mV",
        "vm_max_mV",
        "vm_min_mV",
        "spike_count",
    ]
    for key in required:
        if key not in data:
            raise KeyError(f"Key '{key}' not found in npy. Keys: {list(data.keys())}")
    return data


def _grid_axes_from_positions(positions_um: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Return sorted unique x/y/z coordinate arrays from sparse coordinates."""
    if positions_um.ndim != 2 or positions_um.shape[1] != 3:
        raise ValueError(f"positions_um shape must be (N, 3), got {positions_um.shape}")

    x = np.round(positions_um[:, 0], 6)
    y = np.round(positions_um[:, 1], 6)
    z = np.round(positions_um[:, 2], 6)

    xu = np.unique(x)
    yu = np.unique(y)
    zu = np.unique(z)
    xu.sort()
    yu.sort()
    zu.sort()

    return xu, yu, zu


def _build_metric_volumes(payload: dict) -> Tuple[Dict[str, np.ndarray], np.ndarray, np.ndarray, np.ndarray]:
    """
    Build full-grid 3D volumes for each metric.

    The summary positions can be sparse on the Cartesian lattice.
    We fill dense (nx, ny, nz) arrays with NaN, then map each existing coordinate.
    """
    positions = np.asarray(payload["positions_um"], dtype=np.float64)
    outside_idx = np.asarray(payload["positions_outside_indices"], dtype=np.int64)

    xu, yu, zu = _grid_axes_from_positions(positions)
    nx, ny, nz = xu.size, yu.size, zu.size
    n_all = positions.shape[0]

    metrics_1d = {
        "vm0_mV": np.asarray(payload["vm0_mV"], dtype=np.float64),
        "vm_max_mV": np.asarray(payload["vm_max_mV"], dtype=np.float64),
        "vm_min_mV": np.asarray(payload["vm_min_mV"], dtype=np.float64),
        "spike_count": np.asarray(payload["spike_count"], dtype=np.float64),
    }

    for name, arr in metrics_1d.items():
        if arr.shape[0] != outside_idx.shape[0]:
            raise ValueError(
                f"{name} length mismatch. {name}: {arr.shape[0]}, "
                f"positions_outside_indices: {outside_idx.shape[0]}"
            )
    if np.any(outside_idx < 0) or np.any(outside_idx >= n_all):
        raise ValueError("positions_outside_indices contains out-of-range indices.")

    x = np.round(positions[:, 0], 6)
    y = np.round(positions[:, 1], 6)
    z = np.round(positions[:, 2], 6)

    xi = np.searchsorted(xu, x)
    yi = np.searchsorted(yu, y)
    zi = np.searchsorted(zu, z)

    valid = (
        (xi >= 0) & (xi < nx) &
        (yi >= 0) & (yi < ny) &
        (zi >= 0) & (zi < nz) &
        (xu[xi] == x) &
        (yu[yi] == y) &
        (zu[zi] == z)
    )
    if not np.all(valid):
        bad = int(np.sum(~valid))
        raise ValueError(f"Coordinate-to-grid mapping failed for {bad} points.")

    # Optional safety check for duplicated coordinates.
    flat = xi * (ny * nz) + yi * nz + zi
    if np.unique(flat).size != flat.size:
        raise ValueError("Duplicate coordinates found in positions_um; cannot build unique voxel map.")

    volumes: Dict[str, np.ndarray] = {}
    for name, values in metrics_1d.items():
        vol = np.full((nx, ny, nz), np.nan, dtype=np.float64)
        # If outside_idx is identity (0..N-1), this assignment is equivalent to using all points.
        # Keeping outside_idx preserves compatibility with payload semantics.
        vol[xi[outside_idx], yi[outside_idx], zi[outside_idx]] = values
        volumes[name] = vol

    return volumes, xu, yu, zu


def _nearest_idx(axis_vals: np.ndarray, value: float) -> int:
    return int(np.argmin(np.abs(axis_vals - value)))


def _safe_step(axis_vals: np.ndarray) -> float:
    if axis_vals.size < 2:
        return 1.0
    diffs = np.diff(axis_vals)
    diffs = diffs[np.isfinite(diffs) & (diffs > 0)]
    if diffs.size == 0:
        return 1.0
    return float(np.min(diffs))


def _finite_minmax(vol: np.ndarray) -> Tuple[float, float]:
    finite = vol[np.isfinite(vol)]
    if finite.size == 0:
        return 0.0, 1.0
    return float(np.min(finite)), float(np.max(finite))


def _metric_scale(vol: np.ndarray, metric: str) -> Tuple[float, float, str]:
    """Return (vmin, vmax, cmap_name) for metric."""
    mn, mx = _finite_minmax(vol)
    if metric in ("vm0_mV",):
        abs_max = max(abs(mn), abs(mx))
        if abs_max <= 0:
            abs_max = 1e-6
        return -abs_max, abs_max, "RdBu_r"
    if metric in ("vm_max_mV", "vm_min_mV"):
        if mx <= mn:
            mx = mn + 1e-6
        return mn, mx, "viridis"
    # spike_count
    if mx <= mn:
        mx = mn + 1.0
    return mn, mx, "magma"


def show_interactive(payload: dict, input_path: Path) -> None:
    volumes, xu, yu, zu = _build_metric_volumes(payload)
    nx, ny, nz = xu.size, yu.size, zu.size

    metric_names = ["vm0_mV", "vm_max_mV", "vm_min_mV", "spike_count"]
    metric_label = {
        "vm0_mV": "Vm at t=0 (mV)",
        "vm_max_mV": "Vm max (mV)",
        "vm_min_mV": "Vm min (mV)",
        "spike_count": "Spike count",
    }

    init_metric = "vm_max_mV"
    init_vol = volumes[init_metric]

    # Initial slider defaults requested by user.
    xi0 = _nearest_idx(xu, 80.0)
    yi0 = _nearest_idx(yu, 35.0)
    zi0 = nz // 2

    fig = plt.figure(figsize=(16, 7))
    gs = fig.add_gridspec(2, 4, height_ratios=[1, 0.15], hspace=0.30, wspace=0.45)

    ax_xy = fig.add_subplot(gs[0, 0])
    ax_yz = fig.add_subplot(gs[0, 1])
    ax_zx = fig.add_subplot(gs[0, 2])
    ax_info = fig.add_subplot(gs[0, 3])
    ax_info.axis("off")

    cmap_obj = plt.get_cmap("viridis").copy()
    cmap_obj.set_bad(color="black")

    im_xy = ax_xy.imshow(init_vol[:, :, zi0].T, origin="lower", aspect="equal", cmap=cmap_obj)
    im_yz = ax_yz.imshow(init_vol[xi0, :, :].T, origin="lower", aspect="equal", cmap=cmap_obj)
    im_zx = ax_zx.imshow(init_vol[:, yi0, :].T, origin="lower", aspect="equal", cmap=cmap_obj)

    ax_xy.set_xlabel("x (um)")
    ax_xy.set_ylabel("y (um)")
    ax_yz.set_xlabel("y (um)")
    ax_yz.set_ylabel("z (um)")
    ax_zx.set_xlabel("x (um)")
    ax_zx.set_ylabel("z (um)")

    cbar = fig.colorbar(im_xy, ax=[ax_xy, ax_yz, ax_zx], shrink=0.9)
    cbar.set_label(metric_label[init_metric])

    # Sliders
    ax_x = fig.add_subplot(gs[1, 0])
    ax_y = fig.add_subplot(gs[1, 1])
    ax_z = fig.add_subplot(gs[1, 2])
    ax_dummy = fig.add_subplot(gs[1, 3])
    ax_dummy.axis("off")

    x_sl = Slider(ax_x, "x (um)", float(xu[0]), float(xu[-1]), valinit=float(xu[xi0]), valstep=_safe_step(xu))
    y_sl = Slider(ax_y, "y (um)", float(yu[0]), float(yu[-1]), valinit=float(yu[yi0]), valstep=_safe_step(yu))
    z_sl = Slider(ax_z, "z (um)", float(zu[0]), float(zu[-1]), valinit=float(zu[zi0]), valstep=_safe_step(zu))

    # Radio buttons for metric selection (inside the right info panel, top area)
    info_pos = ax_info.get_position()
    rax = fig.add_axes(
        [
            info_pos.x0 + 0.05 * info_pos.width,
            info_pos.y0 + 0.72 * info_pos.height,
            0.90 * info_pos.width,
            0.24 * info_pos.height,
        ]
    )
    metric_radio = RadioButtons(rax, metric_names, active=metric_names.index(init_metric))
    rax.set_title("Metric", fontsize=10, pad=2)

    stats_text = ax_info.text(
        0.02,
        0.66,
        "",
        ha="left",
        va="top",
        fontsize=9,
        family="monospace",
    )

    # cache scale by metric for stable color range
    metric_scale_cache: Dict[str, Tuple[float, float, str]] = {
        name: _metric_scale(volumes[name], name) for name in metric_names
    }

    def _set_ticks(ax, arr, axis):
        ticks_idx = np.linspace(0, len(arr) - 1, 5, dtype=int)
        labels = [f"{arr[i]:.0f}" for i in ticks_idx]
        if axis == "x":
            ax.set_xticks(ticks_idx)
            ax.set_xticklabels(labels)
        else:
            ax.set_yticks(ticks_idx)
            ax.set_yticklabels(labels)

    def _fmt_stats(metric: str, vol: np.ndarray, xi: int, yi: int, zi: int) -> str:
        finite = vol[np.isfinite(vol)]
        if finite.size == 0:
            return f"[{metric}] no finite data"

        gmin = float(np.min(finite))
        gmax = float(np.max(finite))
        gmean = float(np.mean(finite))
        gstd = float(np.std(finite))

        xy = vol[:, :, zi]
        yz = vol[xi, :, :]
        zx = vol[:, yi, :]

        def mm(a: np.ndarray) -> Tuple[float, float]:
            f = a[np.isfinite(a)]
            if f.size == 0:
                return np.nan, np.nan
            return float(np.min(f)), float(np.max(f))

        mn_xy, mx_xy = mm(xy)
        mn_yz, mx_yz = mm(yz)
        mn_zx, mx_zx = mm(zx)

        lines = [
            f"file: {input_path.name}",
            f"metric: {metric}",
            "",
            f"global min  : {gmin: .6g}",
            f"global max  : {gmax: .6g}",
            f"global mean : {gmean: .6g}",
            f"global std  : {gstd: .6g}",
            "",
            f"XY min/max @ z={zu[zi]:.0f} : {mn_xy: .6g} / {mx_xy: .6g}",
            f"YZ min/max @ x={xu[xi]:.0f} : {mn_yz: .6g} / {mx_yz: .6g}",
            f"ZX min/max @ y={yu[yi]:.0f} : {mn_zx: .6g} / {mx_zx: .6g}",
        ]
        return "\n".join(lines)

    def update_view(_=None):
        metric = metric_radio.value_selected
        vol = volumes[metric]

        xi = _nearest_idx(xu, float(x_sl.val))
        yi = _nearest_idx(yu, float(y_sl.val))
        zi = _nearest_idx(zu, float(z_sl.val))

        slice_xy = vol[:, :, zi]
        slice_yz = vol[xi, :, :]
        slice_zx = vol[:, yi, :]

        vmin, vmax, cmap_name = metric_scale_cache[metric]
        cmap_sel = plt.get_cmap(cmap_name).copy()
        cmap_sel.set_bad(color="black")
        for im in (im_xy, im_yz, im_zx):
            im.set_cmap(cmap_sel)
            im.set_clim(vmin, vmax)

        im_xy.set_data(slice_xy.T)
        im_yz.set_data(slice_yz.T)
        im_zx.set_data(slice_zx.T)

        # tick labels as physical coordinates
        _set_ticks(ax_xy, xu, "x")
        _set_ticks(ax_xy, yu, "y")
        _set_ticks(ax_yz, yu, "x")
        _set_ticks(ax_yz, zu, "y")
        _set_ticks(ax_zx, xu, "x")
        _set_ticks(ax_zx, zu, "y")

        ax_xy.set_title(f"XY ({metric}) z={zu[zi]:.0f} um")
        ax_yz.set_title(f"YZ ({metric}) x={xu[xi]:.0f} um")
        ax_zx.set_title(f"ZX ({metric}) y={yu[yi]:.0f} um")

        cbar.update_normal(im_xy)
        cbar.set_label(metric_label[metric])
        stats_text.set_text(_fmt_stats(metric, vol, xi, yi, zi))

        fig.canvas.draw_idle()

    x_sl.on_changed(update_view)
    y_sl.on_changed(update_view)
    z_sl.on_changed(update_view)
    metric_radio.on_clicked(update_view)

    update_view()
    plt.show()


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "simulate_allen_v3_mp.py summary 결과를 3-slice 슬라이더 뷰어로 시각화하고, "
            "라디오 버튼으로 metric(vmin/vmax/spike 등)을 전환합니다."
        )
    )
    parser.add_argument(
        "--input",
        type=str,
        default=None,
        help="Path to summary npy. Default: latest matching file in ./output",
    )
    args = parser.parse_args()

    script_dir = Path(__file__).resolve().parent
    input_path = Path(args.input) if args.input else _find_default_input(script_dir)
    if input_path is None:
        raise SystemExit(
            "Input file not found. Check ./output/allpoints_cell*_outsideOnly_integrated_mp_summary*.npy"
        )
    if not input_path.exists():
        raise SystemExit(f"Input file does not exist: {input_path}")

    payload = _load_payload(input_path)
    print(f"Loaded: {input_path}")
    print("Opening interactive viewer...")
    show_interactive(payload, input_path)


if __name__ == "__main__":
    main()
