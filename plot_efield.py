# plot_efield.py
"""
Downsampled 3D E-field snapshots (units: V/m).

Implemented:
- Use npy values as-is (no unit conversion; file units).
- Capture one image every TIME_STRIDE_MS (default: 0.1 ms).
- Spatial downsampling to approx GRID_SPACING_UM (default: 20 um) via voxel binning.
- Exclude points inside coil region box [um].
- Render as 3D POINTS (not arrows).
- Larger |E| -> darker color (Greys colormap).
- |E| < E_MIN -> transparent (omitted).
"""

import os
import sys
import glob
import warnings

warnings.filterwarnings("ignore", category=UserWarning, module="numpy")

import numpy as np
import matplotlib

matplotlib.use("Agg")  # capture-only
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from matplotlib.ticker import FuncFormatter
from tqdm import tqdm

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
E_FIELD_VALUES_FILE = os.path.join(SCRIPT_DIR, "efield", "E_field_4cycle.npy")
E_GRID_COORDS_FILE = os.path.join(SCRIPT_DIR, "efield", "E_field_grid_coords.npy")
PLOT_DIR = os.path.join(SCRIPT_DIR, "plot")

DT_MS = 0.05  # time step of E_field_4cycle.npy [ms]
TIME_STRIDE_MS = 0.05  # capture cadence (e.g. 0.1 -> 0.01)
GRID_SPACING_UM = 5.0  # voxel size for spatial downsample (e.g. 20 -> 10)
E_MIN = 1e-4  # threshold in V/m; values below -> transparent (omitted)
VMAX_PERCENTILE = 99.5  # fixed color scale vmax across all frames (percentile over sampled values)
VMAX_SAMPLES_PER_FRAME = 20000  # sample count used to estimate global vmax

# --- Optional limits (ROI) ---
# Time ROI (ms): restrict captures to meaningful time window(s)
TIME_ROI_MS = (0.0, 0.5)  # (start_ms, end_ms). Set to None for full range.
# If the same waveform repeats every PERIOD_MS, you can capture the ROI for each period.
ENABLE_PERIODIC_TIME = False
PERIOD_MS = 10.0
# Which periods to capture when ENABLE_PERIODIC_TIME=True.
# Example: (0, 0) => only the first ROI window (0~0.5 ms total-time).
#          (0, 3) => capture 0~0.5, 10~10.5, 20~20.5, 30~30.5 ms
PERIOD_INDEX_RANGE = (0, 0)

# Space ROI (um): restrict to meaningful spatial box. Set any to None for full.
X_ROI_UM = (-200.0, 200.0)
Y_ROI_UM = (-200.0, 200.0)
Z_ROI_UM = (400.0, 800.0)

# Coil region [um]: exclude points inside this box
COIL_X_MIN, COIL_X_MAX = -79.5, 79.5
COIL_Y_MIN, COIL_Y_MAX = -32.0, 32.0
COIL_Z_MIN, COIL_Z_MAX = 498.0, 1502.0

# Rendering
POINT_SIZE = 2.0
POINT_ALPHA = 0.9
VIEW_ELEV = 25
VIEW_AZIM = 45
COLORMAP = "magma_r"  # colored + high values darker
COLORBAR_SCALE = 1e4  # show values as (V/m * 1e4), so 1 ↔ 1e-4 V/m, etc.


def delete_generated_plots() -> int:
    """Delete plots generated by this script and return count deleted."""
    os.makedirs(PLOT_DIR, exist_ok=True)
    patterns = [
        os.path.join(PLOT_DIR, "efield_points_*.png"),
    ]
    deleted = 0
    for pat in patterns:
        for path in glob.glob(pat):
            try:
                os.remove(path)
                deleted += 1
            except OSError:
                pass
    return deleted


def _compute_voxel_representatives(coords_um: np.ndarray, valid_idx: np.ndarray, spacing_um: float) -> np.ndarray:
    """Pick one representative index per voxel (first occurrence) among valid_idx."""
    pts = coords_um[valid_idx]
    mins = pts.min(axis=0)
    v = np.floor((pts - mins) / spacing_um).astype(np.int32)

    nx = int(v[:, 0].max()) + 1
    ny = int(v[:, 1].max()) + 1
    key = (v[:, 0].astype(np.int64) + v[:, 1].astype(np.int64) * nx + v[:, 2].astype(np.int64) * nx * ny)
    _, first_pos = np.unique(key, return_index=True)
    return valid_idx[first_pos]


def main():
    os.makedirs(PLOT_DIR, exist_ok=True)

    E = np.load(E_FIELD_VALUES_FILE)  # file units as-is
    coords_m = np.load(E_GRID_COORDS_FILE)
    coords_um = coords_m * 1e6

    n_comp, n_space, n_time = E.shape
    if n_comp >= 3:
        Ex, Ey, Ez = E[0], E[1], E[2]
    else:
        Ex, Ez = E[0], E[1]
        Ey = np.zeros_like(Ex)

    x_um = coords_um[:, 0]
    y_um = coords_um[:, 1]
    z_um = coords_um[:, 2]
    inside_coil = (
        (x_um >= COIL_X_MIN) & (x_um <= COIL_X_MAX)
        & (y_um >= COIL_Y_MIN) & (y_um <= COIL_Y_MAX)
        & (z_um >= COIL_Z_MIN) & (z_um <= COIL_Z_MAX)
    )
    # Apply optional space ROI first (then exclude coil region)
    roi_mask = np.ones(coords_um.shape[0], dtype=bool)
    if X_ROI_UM is not None:
        roi_mask &= (x_um >= X_ROI_UM[0]) & (x_um <= X_ROI_UM[1])
    if Y_ROI_UM is not None:
        roi_mask &= (y_um >= Y_ROI_UM[0]) & (y_um <= Y_ROI_UM[1])
    if Z_ROI_UM is not None:
        roi_mask &= (z_um >= Z_ROI_UM[0]) & (z_um <= Z_ROI_UM[1])

    valid_idx = np.where(roi_mask & (~inside_coil))[0]

    # Spatial downsample indices (computed once)
    ds_idx = _compute_voxel_representatives(coords_um, valid_idx, GRID_SPACING_UM)

    # Time indices every TIME_STRIDE_MS, optionally restricted to ROI and repeated every PERIOD_MS
    step = max(1, int(round(TIME_STRIDE_MS / DT_MS)))
    total_ms = (n_time - 1) * DT_MS

    def ms_to_idx(t_ms: float) -> int:
        return int(round(t_ms / DT_MS))

    if TIME_ROI_MS is None:
        windows = [(0.0, total_ms)]
    else:
        windows = [(float(TIME_ROI_MS[0]), float(TIME_ROI_MS[1]))]

    if ENABLE_PERIODIC_TIME and TIME_ROI_MS is not None:
        # Replicate the ROI window at k*PERIOD_MS within available time range
        base_start, base_end = windows[0]
        windows = []
        k0, k1 = PERIOD_INDEX_RANGE
        k = int(k0)
        while True:
            if k > k1:
                break
            ws = base_start + k * PERIOD_MS
            we = base_end + k * PERIOD_MS
            if ws > total_ms:
                break
            windows.append((ws, min(we, total_ms)))
            k += 1

    t_set = set()
    for (ws, we) in windows:
        ws = max(0.0, ws)
        we = min(total_ms, we)
        if we < ws:
            continue
        i0 = max(0, min(n_time - 1, ms_to_idx(ws)))
        i1 = max(0, min(n_time - 1, ms_to_idx(we)))
        for i in range(i0, i1 + 1, step):
            t_set.add(int(i))
    t_indices = np.array(sorted(t_set), dtype=int)

    # Axis limits: full data or ROI (use ROI if set for clearer plots)
    if X_ROI_UM is None:
        xlim = (coords_um[:, 0].min(), coords_um[:, 0].max())
    else:
        xlim = X_ROI_UM
    if Y_ROI_UM is None:
        ylim = (coords_um[:, 1].min(), coords_um[:, 1].max())
    else:
        ylim = Y_ROI_UM
    if Z_ROI_UM is None:
        zlim = (coords_um[:, 2].min(), coords_um[:, 2].max())
    else:
        zlim = Z_ROI_UM

    # Pass 1: estimate a fixed vmax across frames (sample-based, avoids full scan)
    sampled = []
    rng = np.random.default_rng(42)
    for t_idx in tqdm(t_indices, desc="Estimate fixed vmax", unit="frame", ncols=80):
        ex = Ex[ds_idx, t_idx]
        ey = Ey[ds_idx, t_idx]
        ez = Ez[ds_idx, t_idx]
        emag = np.sqrt(ex**2 + ey**2 + ez**2)
        emag = emag[emag >= E_MIN]
        if emag.size == 0:
            continue
        if emag.size > VMAX_SAMPLES_PER_FRAME:
            take = rng.choice(emag.size, size=VMAX_SAMPLES_PER_FRAME, replace=False)
            emag = emag[take]
        sampled.append(emag.astype(np.float64, copy=False))
    if sampled:
        sampled_all = np.concatenate(sampled)
        vmax_fixed = float(np.percentile(sampled_all, VMAX_PERCENTILE))
        if not np.isfinite(vmax_fixed) or vmax_fixed <= E_MIN:
            vmax_fixed = float(np.max(sampled_all))
    else:
        vmax_fixed = E_MIN * 10.0
    print(f"Fixed color scale: vmin={E_MIN:g}, vmax={vmax_fixed:g} (file units, p{VMAX_PERCENTILE})")

    saved = 0
    pbar = tqdm(t_indices, desc="Capture 3D frames", unit="frame", ncols=100)
    for t_idx in pbar:
        ex = Ex[ds_idx, t_idx]
        ey = Ey[ds_idx, t_idx]
        ez = Ez[ds_idx, t_idx]
        emag = np.sqrt(ex**2 + ey**2 + ez**2)

        mask = emag >= E_MIN
        if not np.any(mask):
            pbar.set_postfix_str(f"t={t_idx * DT_MS:.2f}ms saved={saved}")
            continue

        xs = coords_um[ds_idx[mask], 0]
        ys = coords_um[ds_idx[mask], 1]
        zs = coords_um[ds_idx[mask], 2]
        cs = emag[mask]

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection="3d")

        # Fixed scale across frames: larger -> darker (colored colormap), norm always in V/m
        norm = Normalize(vmin=E_MIN, vmax=vmax_fixed, clip=True)
        ax.scatter(
            xs,
            ys,
            zs,
            c=cs,
            cmap=COLORMAP,
            norm=norm,
            s=POINT_SIZE,
            alpha=POINT_ALPHA,
            linewidths=0,
        )

        ax.set_xlabel("x (um)")
        ax.set_ylabel("y (um)")
        ax.set_zlabel("z (um)")
        ax.set_xlim(*xlim)
        ax.set_ylim(*ylim)
        ax.set_zlim(*zlim)
        ax.view_init(elev=VIEW_ELEV, azim=VIEW_AZIM)

        t_ms = t_idx * DT_MS
        ax.set_title(
            f"E-field points at t={t_ms:.2f} ms | grid={GRID_SPACING_UM:.0f}um | E<{E_MIN:g} transparent (file units)"
        )

        # Colorbar (fixed scale). Only the TICK LABELS are scaled for display; all calculations stay in V/m.
        cbar = fig.colorbar(
            plt.cm.ScalarMappable(norm=norm, cmap=COLORMAP),
            ax=ax,
            shrink=0.6,
        )

        def _cb_fmt(val, pos):
            # val is in V/m; show scaled value (e.g. ×1e4 so 1 ↔ 1e-4 V/m)
            return f"{val * COLORBAR_SCALE:g}"

        cbar.formatter = FuncFormatter(_cb_fmt)
        cbar.update_ticks()
        cbar.set_label(f"|E| (×10⁻4 V/m)" if COLORBAR_SCALE == 1e4 else f"|E| (V/m × {COLORBAR_SCALE:g})")
        # File name includes absolute time (ms). If periodic capture is enabled, this will show 10.xx, 20.xx, ...
        out = os.path.join(PLOT_DIR, f"efield_points_{t_ms:06.2f}ms.png")
        plt.tight_layout()
        plt.savefig(out, dpi=150, bbox_inches="tight")
        plt.close(fig)
        saved += 1
        pbar.set_postfix_str(f"t={t_ms:.2f}ms saved={saved}")

    print(f"Done. Expected frames={len(t_indices)}, saved={saved} (skipped when no |E|>=E_MIN).")


if __name__ == "__main__":
    if "-d" in sys.argv or "--delete" in sys.argv:
        n = delete_generated_plots()
        print(f"Deleted {n} file(s) from: {PLOT_DIR}")
        sys.exit(0)
    main()
