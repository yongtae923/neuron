# simulate_tES 버전별 차이점 분석

## 목차
1. [v0 코드 개요](#v0-코드-개요)
2. [v1과 v0의 차이](#v1과-v0의-차이)
3. [v2와 v1의 차이](#v2와-v1의-차이)
4. [v3와 v2의 차이](#v3와-v2의-차이)
5. [v4와 v3의 차이](#v4와-v3의-차이)
6. [요약 비교표](#요약-비교표)

---

## v0 코드 개요

### 주요 특징
- **단일 모델 지원**: `SimplePyramidal` 모델만 사용
- **간단한 E-field 적용**: Z축 방향(Ez)만 고려하는 단순화된 방식
- **하드코딩된 경로**: 파일 경로가 스크립트 디렉토리 기준이 아닌 현재 작업 디렉토리 기준
- **기본적인 시뮬레이션**: 워밍업 시간 없이 바로 E-field 적용

### 핵심 구조

#### 1. 데이터 로드
```python
E_FIELD_VALUES_FILE = 'E_field_40cycles.npy'  # 상대 경로
E_GRID_COORDS_FILE = 'E_field_grid_coords.npy'
```

#### 2. E-field 적용 방식
- **단순화된 접근**: 축삭돌기가 Z축에 평행하다고 가정
- **Ez만 사용**: Ex는 무시
- **버그 존재**: `Ez_interp = Ez_prev + ratio * (Ez_next - Ez_next)` (122번 줄)
- **매우 작은 E_factor**: `E_factor = 0.0000000001` (141번 줄) - 실제로는 거의 효과 없음

#### 3. 뉴런 생성
```python
from simple_pyramidal_model import SimplePyramidal
neurons = []
for i, (x, y, z) in enumerate(N_POSITIONS):
    neuron = SimplePyramidal(x=x, y=y, z_center=z)
    neurons.append(neuron)
```

#### 4. 결과 출력
- 개별 플롯으로 각 뉴런마다 별도 figure 생성
- 파일 저장 없이 `plt.show()`만 사용

---

## v1과 v0의 차이

### 1. 모델 선택 기능 추가

**v0:**
```python
from simple_pyramidal_model import SimplePyramidal
# SimplePyramidal만 사용
```

**v1:**
```python
MODEL_TYPE = 'allen'  # 'simple' 또는 'allen' 선택 가능

if MODEL_TYPE == 'simple':
    from simple_pyramidal_model import SimplePyramidal
elif MODEL_TYPE == 'allen':
    from allen_neuron_model import AllenNeuronModel, ALLEN_DATA_DIR
```

**의미**: Allen Brain Atlas 모델 지원 추가로 더 현실적인 뉴런 모델 사용 가능

---

### 2. 파일 경로 관리 개선

**v0:**
```python
E_FIELD_VALUES_FILE = 'E_field_40cycles.npy'  # 현재 작업 디렉토리 기준
```

**v1:**
```python
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
E_FIELD_VALUES_FILE = os.path.join(SCRIPT_DIR, 'E_field_40cycles.npy')
OUTPUT_DIR = os.path.join(SCRIPT_DIR, 'simulate_tES_output')
os.makedirs(OUTPUT_DIR, exist_ok=True)
```

**의미**: 스크립트 위치 기준으로 경로 설정하여 어디서 실행해도 동일하게 작동

---

### 3. E-field 보간 버그 수정

**v0 (버그):**
```python
Ez_interp = Ez_prev + ratio * (Ez_next - Ez_next)  # 항상 Ez_prev와 같음!
```

**v1 (수정):**
```python
Ez_interp = Ez_prev + ratio * (Ez_next - Ez_prev)  # 올바른 선형 보간
```

**의미**: 시간 보간이 제대로 작동하여 E-field 값이 시간에 따라 부드럽게 변화

---

### 4. E-field 변환 계수 정상화

**v0:**
```python
E_factor = 0.0000000001  # 거의 효과 없음
```

**v1:**
```python
E_factor = 1e-3  # V/m -> mV/um 변환 계수 (정상)
```

**의미**: E-field가 실제로 뉴런에 영향을 미치도록 수정

---

### 5. 결과 저장 기능 추가

**v0:**
```python
plt.show()  # 화면에만 표시
```

**v1:**
```python
# 서브플롯으로 통합
fig, axes = plt.subplots(3, 1, figsize=(12, 10))

# 파일로 저장
if MODEL_TYPE == 'allen' and CELL_ID:
    output_filename = f'allen_{CELL_ID}_neuron_response_all_v1.png'
else:
    output_filename = f'simple_neuron_response_all_v1.png'
output_path = os.path.join(OUTPUT_DIR, output_filename)
plt.savefig(output_path, dpi=300, bbox_inches='tight')
```

**의미**: 
- 3개 뉴런을 하나의 figure에 서브플롯으로 통합
- 파일로 자동 저장하여 결과 보존
- 모델 타입과 cell ID를 파일명에 포함

---

### 6. Cell ID 자동 추출

**v1 추가:**
```python
import re
folder_name = os.path.basename(ALLEN_DATA_DIR)
match = re.search(r'(\d+)$', folder_name)
CELL_ID = match.group(1) if match else None
```

**의미**: Allen 모델 폴더명에서 cell ID를 자동으로 추출하여 파일명에 사용

---

## v2와 v1의 차이

### 1. 다중 모델 일괄 실행

**v1:**
```python
MODEL_TYPE = 'allen'  # 하나만 선택
# ... 시뮬레이션 실행 ...
```

**v2:**
```python
MODEL_TYPES = ['simple', 'allen']  # 여러 모델을 리스트로 지정

for MODEL_TYPE in MODEL_TYPES:
    # 각 모델에 대해 시뮬레이션 실행
    # ... 뉴런 생성 ...
    # ... 시뮬레이션 실행 ...
    # ... 결과 저장 ...
```

**의미**: 한 번의 실행으로 여러 모델 타입의 결과를 모두 얻을 수 있음

---

### 2. E-field 적용 방식 선택

**v1:**
```python
# 'simple' 방식만 사용
# phi = -(E·r) 방식
```

**v2:**
```python
E_FIELD_METHOD = 'integrated'  # 'simple' 또는 'integrated'

if E_FIELD_METHOD == 'integrated':
    # pt3d 기반 적분 방식
    # - morphology의 실제 경로를 따라 E-field를 적분
    # - 더 정확한 전위 계산
else:
    # 'simple' 방식: phi = -(E·r)
```

**의미**: 
- **'simple'**: 각 세그먼트의 중심 좌표에서 `phi = -(E·r)` 계산 (빠르지만 근사)
- **'integrated'**: morphology의 pt3d 점들을 따라 경로 적분 (느리지만 정확)

---

### 3. 워밍업 시간 추가

**v1:**
```python
h.finitialize(-65.0 * mV)
# 바로 E-field 적용 시작
```

**v2:**
```python
WARMUP_TIME_MS = 200.0  # 워밍업 시간

# 1. 워밍업 단계: E-field 없이 평형으로 수렴
while h.t < WARMUP_TIME_MS:
    h.fadvance()

# 2. E-field 적용 단계
while h.t < h.tstop:
    current_time_ms = h.t - WARMUP_TIME_MS  # 상대 시간 사용
    set_extracellular_field()
    # ...
```

**의미**: 
- 초기화 오차를 수렴시켜 안정적인 시뮬레이션 시작
- 실제 resting potential 측정 가능
- E-field 데이터 인덱스는 워밍업 시간을 제외한 상대 시간 사용

---

### 4. E-field 단위 스케일 및 정규화

**v2 추가:**
```python
# FEM E-field 단위 스케일
E_UNIT_SCALE = 1000.0  # V/mm → V/m 변환

# E-field 정규화
TARGET_E_PEAK = 10.0  # V/m 목표 피크

# 정규화 스케일 자동 계산
all_Ex_max = np.max(np.abs(E_field_values[0, :, :]))
all_Ez_max = np.max(np.abs(E_field_values[1, :, :]))
measured_peak = max(all_Ex_max, all_Ez_max)
set_extracellular_field._e_scale = TARGET_E_PEAK / measured_peak
```

**의미**: 
- FEM 결과의 단위 불일치 문제 해결 (V/m vs V/mm)
- E-field 크기를 일정한 수준으로 정규화하여 비교 가능

---

### 5. Morphology 캐시 시스템 (integrated 방식)

**v2 추가:**
```python
def build_morph_cache(neuron, grid_coords_um):
    """뉴런의 morphology 캐시를 생성합니다 (pt3d 기반)."""
    # 각 section의 pt3d 점들, arc 길이, 공간 인덱스 등을 미리 계산
    # ...

def compute_phi_sections(neuron, morph_cache, topo, current_time_ms):
    """섹션 트리를 따라 phi를 누적 적분하여 계산합니다."""
    # 부모 section에서 자식 section으로 전위를 전달하며 적분
    # ...
```

**의미**: 
- pt3d 기반으로 morphology의 실제 경로를 따라 E-field 적분
- 부모-자식 관계를 고려한 전위 전달
- 더 정확한 extracellular potential 계산

---

### 6. 상세한 검증 체크리스트

**v2 추가:**
```python
# 체크 1: FEM 필드 크기 확인
# 체크 2: 뉴런 3개 공간 위치 확인
# 체크 3: 뉴런 내부 e_extracellular 구배 확인
# 검증: ΔVm 수치 분석 (soma, distal dendrite)
```

**출력 예시:**
```
[체크 1] FEM 필드 크기 및 단위 확인
  전체 데이터 최대 E-field: 0.001234 V/m
  정규화 스케일: 8103.456
  정규화 후 목표 피크: 10.00 V/m
  ✅ E-field 크기가 정상 범위입니다

[체크 2] 뉴런 3개 공간 위치 확인
  Neuron 1: Grid index: 1234
  Neuron 2: Grid index: 2345
  Neuron 3: Grid index: 3456
  ✅ 3개 뉴런이 서로 다른 그리드 포인트를 보고 있습니다.

[검증] ΔVm 수치 분석
  Neuron 1:
    Peak-to-peak ΔVm: 0.123456 mV (123.456 uV)
    RMS ΔVm: 0.045678 mV (45.678 uV)
    ✅ ΔVm이 충분히 큽니다
```

**의미**: 시뮬레이션 결과의 신뢰성을 자동으로 검증

---

### 7. 추가 데이터 기록

**v1:**
```python
Vm_vecs = [h.Vector() for _ in range(3)]  # Soma Vm만
```

**v2:**
```python
Vm_vecs = [h.Vector() for _ in range(3)]  # Soma Vm
Vext_vecs = [h.Vector() for _ in range(3)]  # Soma vext
Vm_distal_vecs = [h.Vector() for _ in range(3)]  # Distal dendrite Vm
Vext_distal_vecs = [h.Vector() for _ in range(3)]  # Distal dendrite vext
```

**의미**: 
- vext (extracellular potential) 추적
- Distal dendrite에서의 변화도 기록 (soma보다 더 큰 변화 예상)

---

### 8. 향상된 결과 플롯

**v1:**
```python
# Vm만 플롯
ax.plot(t_array, vm_array, label=neuron_label)
```

**v2:**
```python
# Vm (왼쪽 Y축, 파란색)
ax.plot(t_array, vm_array, label=f'{neuron_label} (Vm)', color='blue')

# vext (오른쪽 Y축, 초록색, ×10 스케일)
ax2 = ax.twinx()
ax2.plot(t_array, vext_scaled, label=f'{neuron_label} (vext × 10)', color='green')

# ΔVm (오른쪽 Y축, 주황색, 확대)
ax_dvm = ax.twinx()
ax_dvm.plot(t_array, dvm, label=f'{neuron_label} (ΔVm)', color='orange')
ax_dvm.set_ylim([-0.5, 0.5])  # ±0.5 mV 범위
```

**의미**: 
- Vm, vext, ΔVm을 동시에 시각화
- 실제 resting potential 기준선 표시
- 더 풍부한 정보 제공

---

### 9. 보조 함수 추가

**v2 추가:**
```python
def xyz_at_seg(sec, segx):
    """세그먼트 위치에서의 3D 좌표를 반환 (pt3d 보간)"""

def translate_morphology(all_secs, dx, dy, dz):
    """모든 section의 pt3d 좌표를 이동 (Allen 모델 배치용)"""

def interp_phi(arc_list, phi_list, target_arc):
    """arc 위치에서 phi 값을 보간"""

def get_E_at(spatial_idx, current_time_ms):
    """특정 공간 인덱스와 시간에서 E-field 값 반환 (경계 클리핑 포함)"""
```

**의미**: 코드 모듈화 및 재사용성 향상

---

## v3와 v2의 차이

### 1. 플롯 타입 선택 기능

**v2:**
```python
# 항상 전체 40 cycles 플롯만 생성
fig, axes = plt.subplots(3, 1, figsize=(12, 10))
fig.suptitle(f'Neuron Response to Extracellular Field (40 Cycles) - {MODEL_TYPE.upper()}')
```

**v3:**
```python
PLOT_TYPE = 'single'  # 'all', 'single', 또는 'both'

# All 플롯 (전체 40 cycles)
if PLOT_TYPE in ['all', 'both']:
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    fig.suptitle(f'Neuron Response to Extracellular Field (40 Cycles) - {MODEL_TYPE.upper()}')

# Single Cycle 플롯 (첫 1ms)
if PLOT_TYPE in ['single', 'both']:
    fig_single, axes_single = plt.subplots(3, 1, figsize=(12, 10))
    fig_single.suptitle(f'Neuron Response to Extracellular Field (First 1 ms) - {MODEL_TYPE.upper()}')
```

**의미**: 
- 사용자가 원하는 플롯만 선택적으로 생성 가능
- 전체 시뮬레이션 또는 초기 1ms만 상세히 관찰 가능
- 메모리 및 저장 공간 절약

---

### 2. Single Cycle 플롯 추가

**v2:**
```python
# 전체 40 cycles 플롯만 존재
```

**v3:**
```python
# Single cycle 데이터 추출 (첫 1ms)
SINGLE_CYCLE_TIME_MS = 1.0  # 1ms
t_array_all = t_vec.as_numpy()
cycle_mask = (t_array_all >= 0) & (t_array_all <= SINGLE_CYCLE_TIME_MS)

if np.any(cycle_mask):
    # 첫 1ms만 표시하는 별도 플롯 생성
    # 동일한 구조 (Vm, vext, 축 범위 통일 등)
```

**의미**: 
- 초기 반응을 더 자세히 관찰 가능
- 전체 플롯에서 보이지 않는 미세한 변화 확인
- 시간 해상도가 높은 초기 구간 분석에 유용

---

### 3. 플롯 제목에 Cell ID 추가

**v2:**
```python
fig.suptitle(f'Neuron Response to Extracellular Field (40 Cycles) - {MODEL_TYPE.upper()}')
```

**v3:**
```python
if MODEL_TYPE == 'allen' and ALLEN_CELL_ID:
    fig.suptitle(f'Neuron Response to Extracellular Field (40 Cycles) - {MODEL_TYPE.upper()} (Cell ID: {ALLEN_CELL_ID})')
else:
    fig.suptitle(f'Neuron Response to Extracellular Field (40 Cycles) - {MODEL_TYPE.upper()}')
```

**의미**: 
- Allen 모델 사용 시 어떤 cell ID를 사용했는지 플롯에서 바로 확인 가능
- 여러 cell ID를 비교할 때 구분이 쉬움

---

### 4. 출력 파일명에 버전 표시

**v2:**
```python
output_filename = f'allen_{ALLEN_CELL_ID}_neuron_response_all.png'
output_filename_single = f'allen_{ALLEN_CELL_ID}_neuron_response_single_cycle.png'
```

**v3:**
```python
output_filename = f'allen_{ALLEN_CELL_ID}_neuron_response_all_v3.png'
output_filename_single = f'allen_{ALLEN_CELL_ID}_neuron_response_single_cycle_v3.png'
```

**의미**: 
- 버전별 결과 파일을 구분하여 관리 가능
- 여러 버전의 결과를 동시에 보관하면서 비교 가능

---

### 5. 플롯 축 범위 통일 개선

**v2:**
```python
# 각 서브플롯이 독립적인 축 범위 사용
```

**v3:**
```python
# 전체 데이터에서 Vm과 vext의 최대/최소값 계산 (축 범위 통일용)
all_vm_min = float('inf')
all_vm_max = float('-inf')
all_vext_min = float('inf')
all_vext_max = float('-inf')

for i in range(3):
    vm_array = Vm_vecs[i].as_numpy()
    all_vm_min = min(all_vm_min, np.min(vm_array))
    all_vm_max = max(all_vm_max, np.max(vm_array))
    # ...

# 모든 서브플롯에 동일한 축 범위 적용
ax.set_ylim(vm_ylim)
ax2.set_ylim(vext_ylim)
```

**의미**: 
- 모든 서브플롯에서 동일한 기준으로 비교 가능
- 뉴런 간 차이를 더 명확하게 시각화

---

### 6. vext 스케일 조정 제거

**v2:**
```python
vext_scaled = vext_array * 10  # 스케일 조정 (시각화용)
ax2.plot(t_array, vext_scaled, label=f'{neuron_label} (vext × 10)')
ax2.set_ylabel('Extracellular Potential (mV × 10)')
```

**v3:**
```python
ax2.plot(t_array, vext_array, label=f'{neuron_label} (vext)')
ax2.set_ylabel('Extracellular Potential (mV)')
```

**의미**: 
- 실제 값으로 표시하여 해석이 더 직관적
- 축 단위가 명확하여 혼동 방지

---

### 7. ΔVm 플롯 제거

**v2:**
```python
# Delta Vm 플롯 (확대 보기)
vm_mean = np.mean(vm_array)
dvm = vm_array - vm_mean
ax_dvm = ax.twinx()
ax_dvm.plot(t_array, dvm, label=f'{neuron_label} (ΔVm)', color='orange')
```

**v3:**
```python
# ΔVm 플롯 제거됨 (더 이상 표시하지 않음)
```

**의미**: 
- 플롯이 더 깔끔해짐
- Vm과 vext에 집중하여 핵심 정보만 표시

---

## v4와 v3의 차이

### 1. 다중 E-field 스케일 지원

**v3:**
```python
TARGET_E_PEAK = 10.0  # 단일 목표 피크로 정규화
# 하나의 E-field 강도로만 시뮬레이션
```

**v4:**
```python
E_FIELD_SCALES = [1, 2, 3, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]  # 여러 배수 리스트

for scale_idx, E_FIELD_SCALE in enumerate(E_FIELD_SCALES):
    # 각 스케일에 대해 시뮬레이션 실행
    # 결과를 스케일별로 저장
```

**의미**: 
- 한 번의 실행으로 여러 E-field 강도에 대한 결과를 모두 얻을 수 있음
- 임계값 분석, 용량-반응 곡선 생성에 유용

---

### 2. E-field 단위 변환 개선

**v3:**
```python
E_UNIT_SCALE = 1000.0  # V/mm → V/m 변환
E_factor = 1e-3  # V/m → mV 변환
TARGET_E_PEAK = 10.0  # 정규화 목표
```

**v4:**
```python
E_UNIT_SCALE = 1e6  # V/um → V/m 변환 (Ansys 데이터가 V/um 단위)
E_FACTOR = 1e-3  # (V/m × um) → mV 변환
# 정규화 없음, 원본 기준 배수로 직접 스케일링
```

**의미**: 
- FEM 데이터의 실제 단위(V/um)에 맞춰 정확한 변환
- 정규화 대신 원본 E-field 기준으로 배수 적용 (더 직관적)

---

### 3. 진행률 표시 (tqdm)

**v3:**
```python
print(f"워밍업 중... (0 ~ {WARMUP_TIME_MS} ms)")
while h.t < WARMUP_TIME_MS:
    h.fadvance()
```

**v4:**
```python
from tqdm import tqdm

pbar = tqdm(total=total_steps, desc=f"E-field 시뮬레이션 ({E_FIELD_SCALE:.1f}x)", 
            unit="step", unit_scale=True, ncols=100)

while h.t < h.tstop:
    # ... 시뮬레이션 ...
    pbar.update(1)

pbar.close()
```

**의미**: 
- 긴 시뮬레이션의 진행 상황을 실시간으로 확인 가능
- 예상 완료 시간 표시
- 사용자 경험 향상

---

### 4. 스케일별 파일명

**v3:**
```python
output_filename = f'allen_{ALLEN_CELL_ID}_neuron_response_all_v3.png'
output_filename_single = f'allen_{ALLEN_CELL_ID}_neuron_response_single_cycle_v3.png'
```

**v4:**
```python
scale_suffix = f"_{E_FIELD_SCALE:.0f}x" if E_FIELD_SCALE >= 1.0 else f"_{E_FIELD_SCALE:.1f}x"
output_filename = f'allen_{ALLEN_CELL_ID}_neuron_response_all{scale_suffix}.png'
output_filename_single = f'allen_{ALLEN_CELL_ID}_neuron_response_single_cycle{scale_suffix}.png'
# 예: allen_486239338_neuron_response_single_cycle_10x.png
```

**의미**: 
- 각 E-field 스케일별로 별도 파일 생성
- 여러 스케일의 결과를 쉽게 비교 가능

---

### 5. 뉴런 생성 최적화

**v3:**
```python
# 매 스케일 반복마다 뉴런 새로 생성 (필요시)
```

**v4:**
```python
# 뉴런과 Morphology 캐시를 한 번만 생성
for i, (x, y, z) in enumerate(N_POSITIONS):
    neuron = AllenNeuronModel(x=0, y=0, z=0, cell_id=ALLEN_CELL_ID)
    # ...
neurons = [...]
morph_caches = [...]
topos = [...]

# 여러 스케일에 대해 동일 뉴런으로 시뮬레이션 반복
for E_FIELD_SCALE in E_FIELD_SCALES:
    # E-field 스케일만 변경하며 시뮬레이션
    h.finitialize(-65.0 * mV)
    # ...
```

**의미**: 
- 뉴런 생성 및 캐시 빌드는 한 번만 수행
- 스케일 반복 시 재초기화만 하여 시간 절약

---

### 6. 스케일 전환 시 리셋

**v4 추가:**
```python
# E-field 스케일 리셋
for attr in ['_e_scale_calculated', '_e_scale']:
    if hasattr(set_extracellular_field, attr):
        delattr(set_extracellular_field, attr)

# 다음 스케일로 진행하기 전에 뉴런 재초기화
if scale_idx < len(E_FIELD_SCALES) - 1:
    print(f"\n다음 스케일 ({E_FIELD_SCALES[scale_idx + 1]:.1f}배)로 진행합니다...")
    h.finitialize(-65.0 * mV)
```

**의미**: 
- 각 스케일 시뮬레이션 간 완전한 상태 리셋
- 이전 스케일의 결과가 다음에 영향을 미치지 않도록 보장

---

## 요약 비교표

| 기능 | v0 | v1 | v2 | v3 | v4 |
|------|----|----|----|----|----|----|
| **모델 지원** | SimplePyramidal만 | SimplePyramidal + Allen | SimplePyramidal + Allen (일괄 실행) | SimplePyramidal + Allen (단일 선택) | SimplePyramidal + Allen (단일 선택) |
| **파일 경로** | 하드코딩 | 스크립트 기준 | 스크립트 기준 | 스크립트 기준 | 스크립트 기준 |
| **E-field 보간** | 버그 있음 | 수정됨 | 수정됨 + 경계 클리핑 | 수정됨 + 경계 클리핑 | 수정됨 + 경계 클리핑 |
| **E-field 적용 방식** | 단순 (Ez만) | 단순 (Ez만) | 단순 또는 적분 방식 선택 가능 | 단순 또는 적분 방식 선택 가능 | 단순 또는 적분 방식 선택 가능 |
| **E-factor** | 0.0000000001 (거의 무효) | 1e-3 (정상) | 1e-3 + 정규화 | 1e-3 + 정규화 | 1e-3 (정규화 없음, 원본 배수) |
| **워밍업 시간** | 없음 | 없음 | 200ms | 200ms | 200ms |
| **결과 저장** | 없음 (화면만) | 파일 저장 | 파일 저장 | 파일 저장 (버전 표시) | 파일 저장 (스케일별) |
| **결과 플롯** | 개별 figure | 서브플롯 | 서브플롯 + vext + ΔVm | 서브플롯 + vext (플롯 타입 선택) | 서브플롯 + vext (스케일별 플롯) |
| **플롯 타입 선택** | 없음 | 없음 | 없음 | 'all', 'single', 'both' 선택 가능 | 'all', 'single', 'both' 선택 가능 |
| **Single Cycle 플롯** | 없음 | 없음 | 없음 | 첫 1ms 상세 플롯 | 첫 1ms 상세 플롯 |
| **플롯 제목 Cell ID** | 없음 | 없음 | 없음 | Allen 모델 시 표시 | Allen 모델 시 표시 |
| **플롯 축 범위 통일** | 없음 | 없음 | 없음 | 모든 서브플롯 통일 | 모든 서브플롯 통일 |
| **vext 스케일** | 없음 | 없음 | ×10 스케일 | 원본 값 (스케일 없음) | 원본 값 (스케일 없음) |
| **데이터 기록** | Soma Vm만 | Soma Vm만 | Soma Vm/vext + Distal Vm/vext | Soma Vm/vext + Distal Vm/vext | Soma Vm/vext + Distal Vm/vext |
| **검증 기능** | 없음 | 없음 | 상세 체크리스트 | 상세 체크리스트 | 상세 체크리스트 |
| **E-field 단위 처리** | 없음 | 없음 | V/mm → V/m + 정규화 | V/mm → V/m + 정규화 | V/um → V/m (정확한 단위) |
| **Morphology 캐시** | 없음 | 없음 | integrated 방식에서 사용 | integrated 방식에서 사용 | integrated 방식에서 사용 |
| **다중 E-field 스케일** | 없음 | 없음 | 없음 | 없음 | ✅ 여러 배수 한 번에 실행 |
| **진행률 표시 (tqdm)** | 없음 | 없음 | 없음 | 없음 | ✅ 실시간 진행률 |

---

## 권장 사용 시나리오

### v0 사용 시
- ❌ **권장하지 않음** (버그 및 기능 제한)

### v1 사용 시
- ✅ 단일 모델 타입으로 빠른 테스트
- ✅ 간단한 E-field 적용으로 충분한 경우
- ✅ 워밍업이 필요 없는 경우

### v2 사용 시
- ✅ 여러 모델 타입을 한 번에 비교
- ✅ 정확한 E-field 적용이 필요한 경우 (integrated 방식)
- ✅ 상세한 검증 및 분석이 필요한 경우
- ✅ 논문/발표용 고품질 결과 생성

### v3 사용 시
- ✅ 플롯 타입을 선택적으로 생성하고 싶은 경우
- ✅ 초기 반응(첫 1ms)을 상세히 관찰하고 싶은 경우
- ✅ 여러 버전의 결과를 비교하면서 관리하고 싶은 경우
- ✅ 플롯을 더 깔끔하게 정리하고 싶은 경우 (ΔVm 제거, vext 원본 값)
- ✅ Allen 모델 사용 시 cell ID를 플롯에서 바로 확인하고 싶은 경우

### v4 사용 시
- ✅ 여러 E-field 강도(배수)를 한 번에 시뮬레이션하고 싶은 경우
- ✅ 정확한 단위 변환이 필요한 경우 (V/um → V/m)
- ✅ 진행률 표시(tqdm)로 긴 시뮬레이션을 모니터링하고 싶은 경우
- ✅ E-field 스케일별로 결과를 자동 비교하고 싶은 경우

---

## 마이그레이션 가이드

### v0 → v1
1. `MODEL_TYPE` 변수 추가
2. 파일 경로를 `os.path.join(SCRIPT_DIR, ...)` 형식으로 변경
3. `Ez_interp` 계산식 수정
4. `E_factor` 값을 `1e-3`으로 변경
5. 결과 저장 코드 추가

### v1 → v2
1. `MODEL_TYPES` 리스트로 변경하고 루프 추가
2. `E_FIELD_METHOD` 선택 기능 추가
3. `WARMUP_TIME_MS` 추가 및 워밍업 단계 구현
4. `E_UNIT_SCALE`, `TARGET_E_PEAK` 추가
5. `build_morph_cache`, `compute_phi_sections` 등 함수 추가 (integrated 방식)
6. 검증 체크리스트 추가
7. 추가 데이터 기록 및 플롯 개선

### v2 → v3
1. `PLOT_TYPE` 변수 추가 ('all', 'single', 'both')
2. Single cycle 플롯 생성 로직 추가 (첫 1ms)
3. 플롯 제목에 cell ID 추가 (Allen 모델 시)
4. 출력 파일명에 `_v3` 추가
5. 플롯 축 범위 통일 로직 추가
6. vext 스케일 조정 제거 (×10 → 원본 값)
7. ΔVm 플롯 제거

### v3 → v4
1. `E_FIELD_SCALES` 리스트 추가 (여러 배수 한 번에 실행)
2. `E_UNIT_SCALE` 변경: 1000.0 (V/mm) → 1e6 (V/um)
3. `TARGET_E_PEAK` 제거, 원본 기준 배수로 직접 스케일링
4. `tqdm` 진행률 표시 추가
5. 출력 파일명에 스케일 표시 (`_{scale}x.png`)
6. 스케일 반복 시 상태 리셋 로직 추가
7. 뉴런/캐시 생성 최적화 (한 번만 생성)

---

## 결론

- **v0**: 초기 프로토타입, 버그 및 기능 제한
- **v1**: 기본 기능 완성, 모델 선택 및 결과 저장
- **v2**: 고급 기능 추가, 정확도 향상, 검증 및 분석 도구
- **v3**: 플롯 기능 개선, 선택적 플롯 생성, 사용성 향상
- **v4**: 다중 E-field 스케일 지원, 정확한 단위 변환, 진행률 표시

현재는 **v4 사용을 강력히 권장**합니다.
